generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model user {
  id       String   @id @default(uuid())
  name     String
  email    String   @unique
  birthday DateTime
  password String

  donator  Boolean @default(false)
  avatar   String?
  verified Boolean @default(false) //alterar valor default para false quando terminar
  news     Boolean @default(true)
  access   Boolean @default(false)

  cpf          String? @unique
  phone_number String?

  created_at DateTime @default(now())
  updated_at DateTime @default(now()) @updatedAt

  resetToken       String?
  resetTokenExpire DateTime?

  addressId String?  @unique
  address   address? @relation(fields: [addressId], references: [id], onDelete: Cascade)

  favoritos    favorito[]
  loginHistory loginHistory?
  subscription subscription?
  watchLater   watchLater[]
}

model loginHistory {
  id         String   @id @default(uuid())
  userId     String   @unique
  name       String
  email      String
  lastAccess DateTime @default(now())
  user       user     @relation(fields: [userId], references: [id])
}

model subscription {
  id        String   @id @default(uuid())
  userId    String   @unique
  subId     Int      @unique
  status    String
  planId    String
  startedAt DateTime @default(now())

  //invoices invoice[]
  history subscriptionHistory[]

  plan plan @relation(fields: [planId], references: [id])
  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
}

model subscriptionHistory {
  id             String   @id @default(uuid())
  subscriptionId String
  fromStatus     String
  toStatus       String
  changedAt      DateTime @default(now())

  subscription subscription @relation(fields: [subscriptionId], references: [id])
}

/**
 * model invoice {
 * id       String        @id @default(uuid())
 * status   InvoiceStatus // paid | pending | failed | refunded
 * chargeId Int //ID da cobrança na EFI
 * subscriptionId String?
 * subscription   subscription? @relation(fields: [subscriptionId], references: [id])
 * @@index([status])
 * }
 */

model address {
  id           String  @id @default(uuid())
  street       String
  number       String
  neighborhood String
  zipcode      String
  city         String
  complement   String?
  state        String
  user         user?
}

model plan {
  id         String         @id @default(uuid())
  name       String         @unique
  price      Int
  type       String
  planId     Int            @unique
  created_at DateTime       @default(now())
  updated_at DateTime       @default(now()) @updatedAt
  sub        subscription[]
}

model watchLater {
  id         String   @id @default(uuid())
  title      String
  subtitle   String
  userId     String
  created_at DateTime @default(now())
  updated_at DateTime @default(now()) @updatedAt
  tmdbid     Int
  user       user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model favorito {
  id         String   @id @default(uuid())
  title      String
  subtitle   String?
  userId     String
  created_at DateTime @default(now())
  updated_at DateTime @default(now()) @updatedAt
  tmdbid     Int
  user       user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model problem {
  id          String   @id @default(uuid())
  title       String
  description String
  tmdbId      Int      @unique
  season      Int?
  episode     Int?
  userId      String
  status      String
  created_at  DateTime @default(now())
  updated_at  DateTime @default(now()) @updatedAt
}

//ENUMs

enum SubscriptionStatus {
  active
  inactive
  canceled
  expired
  trial
}

enum InvoiceStatus {
  new //Cobrança gerada, aguardando definição da forma de pagamento. O termo "new" equivale a "novo"
  waiting //Forma de pagamento selecionada, aguardando a confirmação do pagamento. O termo "waiting" equivale a "aguardando".
  identified //Pagamento identificado. O termo "identified" equivale a "identificado". Indica que o pagamento foi efetuado antes do dinheiro ser creditado.
  approved //Pagamento aprovado. O termo "approved" equivale a "aprovado". Indica que o pagamento foi aprovado pela operadora do cartão mas ainda não foi creditado.
  paid //Pagamento confirmado. O termo "paid" equivale a "pago".
  unpaid //Não foi possível confirmar o pagamento da cobrança. O termo "unpaid" equivale a "não pago".
  refunded //Pagamento devolvido pelo lojista ou pelo intermediador Efí. O termo "refunded" equivale a "devolvido".
  contested //Pagamento em processo de contestação. O termo "contested" equivale a "contestado".
  canceled //Cobrança cancelada pelo vendedor ou pelo pagador. O termo "canceled" equivale a "cancelado".
  settled //Cobrança foi confirmada manualmente. O termo "settled" equivale a "marcar como pago".
  expired //A cobrança receberá este status caso nao tenha sito realizado nenhum pagamento e a data maxima de pagamento, definica no atributo days_to_write_off, ou nas configurações da sua conta Efí, seja atingida. O termo "expired" equivale a "expirado".
}
